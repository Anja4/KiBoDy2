
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Kibody</title>
	<style type='text/css'>
		canvas { border: 1px solid black; }
	</style>
	<script type="text/javascript" src="howler.min.js"></script>
</head>
<body>
	<h1>Kibody, the eco friendly Hero</h1>
	<canvas id='canvas' width='800' height='600'></canvas>
	<script type='text/javascript'>
	
	var can = document.getElementById('canvas');
	var ctx;
	var lastTickTime = 0;
	var UPDATEINTERVAL = 1000 / 50;
	var accumulate = 0;
	var update;
	var draw;
	var baddieSpawnInterval = 7000;
	var timeTillBaddieSpawn = 7000;
	var wallet = 0;
	var STORAGE;
	var QUOTES;
	var unlocked = [
		{ value: true, type: "manufactured"},
		{ value: true, type: "oak"},
		{ value: true, type: "petrified"},
		];
		/*for now, I set all of these values to true for testing purposes. Here is what it is supposed to be:
		the first value in the array should always be true (this means you can always place manufactured trees.)
		the other values in the array should start out as false, but picking up a seed will turn a random one (that is currently false) to true
		when you press the "switch types" button, it will change to "types" variable to the index of the next true value in this array.*/
	
	var type = 0;//type we are trying to plant.
	
	var spider = new Image();
	var beedog = new Image();
	var emoTree = new Image();
	var towerTree = new Image();
	var background = new Image();
	var coin = new Image();
	
	var baddies = [];
	var bullets = [];
	var trees = [];
	var speechBubbles = [];
	var pickUp = [];
	var player = {
		x: 0,
		y: 0,
		speed: 150, //speed is measured in pixels per second
		angle: 0,
		width: 30,
		height: 30,
		up: false,
		down: false,
		left: false,
		right: false,
		e: false,
		eHeld: false,
		q: false,
		qHeld: false,
		WAIT: 150,
		timeToWait: 1,
		bulletToFire: {
			x: 0,
			y: 0,
			width: 5,
			height: 5,
			angle: 0,
			speed: 300,
			damage: 25},
		};
	var mouse = {
		x: 0,
		y: 0};	
	var crosshair = {
		gap: 10,
		length: 20,
		width: 2};
	
	var go=false;
	var playButton={x:300,y:350,width:200,height:70}
	var introButton={x:300,y:450,width:200,height:70}
	var backButton={x:300,y:350,width:200,height:70}
	
	var endWaitTime = 5000;
	var endTime = 5000;
	
	
	//*************************PLAY FUNCTIONS****************************
	
	
	
	function playUpdate(time){
		//*****This code moves the player*****
		if(player.up || player.down || player.right || player.left){
			var vert = 0;
			var horz = 0;
			if(player.left)
				horz--;
			if(player.right)
				horz++;
			if(player.up)
				vert--;
			if(player.down)
				vert++;
			var angle = Math.atan2(vert,horz);
			if(horz != 0)
				player.x += Math.cos(angle) * player.speed * time * 0.001;
			if(vert !=0)
				player.y += Math.sin(angle) * player.speed * time * 0.001;
		}
		
		//Collision detection with walls
		if(player.x < 0)
			player.x = 0;
		else if(player.x + player.width > can.width)
			player.x = can.width - player.width;
		if(player.y < 0)
			player.y = 0;
		else if(player.y + player.height > can.height)
			player.y = can.height - player.height;
		
		
		//code for the player's shooting mechanic
		player.timeToWait -= time;
		if(player.timeToWait < 0)
			player.timeToWait = 0;
		
		//******This code moves the bullets*****
		//It also deletes them if they are significantly outside the boundries.
		for(var i = 0; i < bullets.length; i++){
			var xx = can.width / 2;
			var yy = can.height / 2;
			bullets[i].x += Math.cos(bullets[i].angle) * bullets[i].speed * time * 0.001;
			bullets[i].y += Math.sin(bullets[i].angle) * bullets[i].speed * time * 0.001;
			
			if(bullets[i].x < -100 || bullets[i].x > can.width + 100 || bullets[i].y < -100 || bullets[i].y > can.height + 100){
				bullets.splice(i,1);
				i--;
			}
		}
		
		//*****This code moves all the baddies*****
		for(var i = 0; i < baddies.length; i++){
			var col = -1;
			for(var j = 0; j < trees.length; j++){
				if(collide(trees[j],baddies[i]))
					col = j;
			}
			
			baddies[i].hitTime -= time;
			if(baddies[i].hitTime < 0)
				baddies[i].hitTime = 0;
			
			if(col == -1){
				var xx = can.width / 2;
				var yy = can.height / 2;
				var angle = Math.atan2(yy - baddies[i].y - (baddies[i].height * 0.5), xx - baddies[i].x - (baddies[i].width * 0.5));
				baddies[i].x += Math.cos(angle) * baddies[i].speed * time * 0.001;
				baddies[i].y += Math.sin(angle) * baddies[i].speed * time * 0.001;
			}
			else if(baddies[i].hitTime == 0){
				trees[col].health -= baddies[i].damage;
				baddies[i].hitTime = baddies[i].hitInterval;
			}
			
			for(var j = 0; j < bullets.length; j++){//collision detection between bullets and baddies
				if(collide(baddies[i],bullets[j])){
					baddies[i].health -= bullets[j].damage;
					bullets.splice(j,1);
					j--;
				}
			}
		}
		
		//*****This code makes the trees shoot at baddies
		for(var i = 0; i < trees.length; i++){
			
			var treeCenter = {
				x: trees[i].x + (trees[i].width * 0.5),
				y: trees[i].y + (trees[i].height * 0.5)};
				
			trees[i].timeToWait -= time;
			
			if(trees[i].timeToWait <= 0){
			
				var distance = -1;
				var index = -1;
				for(var j = 0; j < baddies.length; j++){
					//find the distance from the center of the tree to the center of the baddie
					var baddieCenter = {
						x: baddies[j].x + (baddies[j].width * 0.5),
						y: baddies[j].y + (baddies[j].height * 0.5)};
					
					var curDist = Math.sqrt(Math.pow(baddieCenter.x - treeCenter.x,2) + Math.pow( baddieCenter.y - treeCenter.y,2));
					if(distance == -1 || curDist < distance){
						index = j;
						distance = curDist;
					}
				}
				if(index != -1 && distance <= trees[i].range){
					var baddieCenter = {
						x: baddies[index].x + (baddies[index].width * 0.5),
						y: baddies[index].y + (baddies[index].height * 0.5),
						};
					var bul = {//The reason why it imports each individual variable is to create a copy of the record, instead of using the reference
						x: treeCenter.x,
						y: treeCenter.y,
						width: trees[i].bulletToFire.width,
						height: trees[i].bulletToFire.height,
						angle: trees[i].bulletToFire.angle,
						speed: trees[i].bulletToFire.speed,
						damage: trees[i].bulletToFire.damage};
					bul.angle = Math.atan2((baddieCenter.y - treeCenter.y) , (baddieCenter.x - treeCenter.x));
					addBullet(bul);
					
					if(Math.random() <= 0.05)
						addSpeechBubble(treeCenter.x,treeCenter.y,trees[i].type);
					
					trees[i].timeToWait += trees[i].WAIT;
				}
				else{
					trees[i].timeToWait += time;
				}
			}
		}
		
		//detect if pickUp is picked up add value to wallet, take coin out of array and delete it
		for(var i = 0; i < pickUp.length; i++){
			if(collide(pickUp[i],player)){ //collision detection between player and pickUp so pickUp can be picked up
				pickUp[i].pickedUp = true;
				wallet += pickUp[i].val;
				pickUp.splice(i,1);
				i--;
				//if we want to add seeds, could add code here?
			}	
		}	
		
		//deleting baddies that have died and move coin to screen
		for(var i = 0; i < baddies.length; i++){
			if(baddies[i].health <= 0){
				var PUx = baddies[i].x + (baddies[i].width * 0.5) - 5; //PUx will be the x of the PickUp
				var PUy = baddies[i].y + (baddies[i].height * 0.5) - 5;
				if(PUx < 0)
					PUx = 0;
				else if(PUx > can.width - 10)
					PUx = can.width - 10;//minus the width of the coin
				if(PUy < 0)
					PUy = 0;
				else if(PUy > can.height - 10)
					PUy = can.height - 10;//minus the height of the coin
				addPickUp(PUx, PUy, 20); //temporary value of 20 (later, different baddies can drop more money?)
				baddies.splice(i,1);
				i--;
			}
		}
		
		//deleting trees that have died. also checks for master tree.
		var mast = false;
		for(var i = 0; i < trees.length; i++){
			if(trees[i].type == "master")
				mast = true;
			if(trees[i].health <= 0){
				trees.splice(i,1);
				i--;
			}
		}
		
		//stuff for speech bubbles
		for(var i = 0; i < speechBubbles.length; i++){
			speechBubbles[i].timeLeft -= time;
			if(speechBubbles[i].timeLeft <= 0){
				speechBubbles.splice(i,1);
				i--;
			}
		}
		
		//spawning baddies
		timeTillBaddieSpawn -= time;
		if(timeTillBaddieSpawn <= 0){
			addBaddie();
			if(baddieSpawnInterval > 500)
				baddieSpawnInterval -= 50;
			timeTillBaddieSpawn = baddieSpawnInterval;
		}
		
		//changing the type of tree the player wants to place
		if(player.q && player.qHeld == false){
			do{
				type++;
				if(type >= unlocked.length)
					type = 0;
			}while(unlocked[type].value == false);
			player.qHeld = true;
		}
		if(player.q == false && player.qHeld)
			player.qHeld = false;
		
		//making trees
		if(player.e == true && player.eHeld == false){
			var xx = player.x + (player.width * 0.5);
			var yy = player.y + (player.height * 0.5);
			xx = Math.floor( xx / 50 ) * 50;
			yy = Math.floor( yy / 50 ) * 50;
			var obj = {x:xx,y:yy,width:50,height:50};
			var canPlace = true;
			for(var i = 0; i < trees.length; i++){
				if(collide(trees[i],obj))
					canPlace = false;
			}
			if(canPlace){//add to this if statement so that it doesn't allow placing trees if they don't have enough money.
				//add a line here to subtract money according to the cost of the tree they planted.
				addTree(xx,yy,unlocked[type].type);
			}
			player.eHeld = true;
		}
		if(player.e == false && player.eHeld == true)
			player.eHeld = false;
		
		//game over if master tree died.
		if(mast == false)
			endSetup();
	}
	
	function playDraw(){
		ctx.clearRect(0,0,can.width, can.height);
		ctx.drawImage(background,0,0);
		
		var xx = player.x + (player.width * 0.5);
		var yy = player.y + (player.height * 0.5);
		xx = Math.floor( xx / 50 ) * 50;
		yy = Math.floor( yy / 50 ) * 50;
		
		ctx.fillStyle = "#FFFFCC";
		ctx.fillRect(xx,yy,50,50);
		
		//Center Tree
		//ctx.drawImage(emoTree, 338, 230);
		
		//Trees
		ctx.fillStyle = "#00FF00";
		for(var i = 0; i < trees.length; i++){
			ctx.drawImage(towerTree,trees[i].x,trees[i].y);
			if(trees[i].type != "manufactured")
				ctx.fillRect(trees[i].x,trees[i].y,trees[i].width,trees[i].height);
		}
		
		//Baddies
		ctx.fillStyle = "#FF0000";
		for(var i = 0; i < baddies.length; i++){
			ctx.drawImage(spider,baddies[i].x,baddies[i].y);
			//ctx.fillRect(baddies[i].x,baddies[i].y,baddies[i].width,baddies[i].height);
		}
		
		//Player
		ctx.fillStyle = "#0000FF";
		ctx.drawImage(beedog,player.x,player.y);
		ctx.fillRect(player.x, player.y, player.width, player.height);
		
		//Bullets
		ctx.fillStyle = "#FF0000";
		for(var j = 0; j < bullets.length; j++){
			ctx.fillRect(bullets[j].x,bullets[j].y,bullets[j].width,bullets[j].height);
		}
		
		//SpeechgBubbles
		ctx.font = "10pt Helvetica";
		for(var i = 0; i < speechBubbles.length; i++){
			ctx.fillStyle = "#FFFFFF";
			ctx.fillRect(speechBubbles[i].x - 30, speechBubbles[i].y - 50, 150, 20);
			ctx.fillStyle = "#000000";
			ctx.fillText(speechBubbles[i].quote, speechBubbles[i].x - 25, speechBubbles[i].y - 35);
		}
		
		//PickUps
		ctx.fillStyle = "#FFCC66";
		for(var k = 0; k < pickUp.length; k++){
			ctx.drawImage(coin,pickUp[k].x,pickUp[k].y);
			//ctx.fillRect(pickUp[k].x, pickUp[k].y, pickUp[k].width, pickUp[k].height);
		}
		//Wallet
		ctx.fillText("Money: " + wallet, 0, 10);
		
		//Type of Tree that you will plant
		ctx.fillStyle = "#BB9999";
		ctx.fillText(unlocked[type].type,580,10);
		
		//Crosshair
		ctx.fillStyle = "#000000";
		ctx.fillRect(mouse.x - (crosshair.width / 2),mouse.y - crosshair.length - crosshair.gap, crosshair.width, crosshair.length);
		ctx.fillRect(mouse.x - (crosshair.width / 2),mouse.y + crosshair.gap, crosshair.width, crosshair.length);
		ctx.fillRect(mouse.x - crosshair.length - crosshair.gap, mouse.y - (crosshair.width/2), crosshair.length, crosshair.width);
		ctx.fillRect(mouse.x + crosshair.gap, mouse.y - (crosshair.width/2), crosshair.length, crosshair.width);
		
		//Things below this line are used for bug fixing.
		ctx.fillStyle = "#000000";
		//ctx.fillText(bullets.length + "",0,10);
		//ctx.fillText(type + "", 0, 10);
	}
	
	//Starting position
	function playSetup(){
		player.x = 385;
		player.y = 285;
		baddieSpawnInterval = 7000;
		if(trees.length > 0)
			trees.splice(0,trees.length);
		if(baddies.length > 0)
			baddies.splice(0,baddies.length);
		if(bullets.length > 0)
			bullets.splice(0,bullets.length);
		if(speechBubbles.length > 0)
			speechBubbles.splice(0,speechBubbles.length);
		spider.src="Baddie.png";
		beedog.src="beedog.png";
		emoTree.src="Tree.png";
		towerTree.src="TreeNew.png";
		background.src="Background.png";
		coin.src="Coin.png";
		
		addTree((can.width * 0.5) - 25, (can.height * 0.5) - 25,"master");
		addSpeechBubble((can.width * 0.5) - 25, (can.height * 0.5) - 25,"master");
		
		update = playUpdate;
		draw = playDraw;
	}
	
	function addBaddie(){
		var bad = {
			x: 0,
			y: 0,
			width: 30,
			height: 30,
			speed: 10,
			health: 100,
			hitInterval: 1000,
			hitTime: 1000,
			damage: 20,
			};
		
		var rand = Math.floor(Math.random() + 0.5);
		var rand2 = Math.floor(Math.random() + 0.5);
		var xx = 0;
		var yy = 0;
		if(rand == 0){ // the x is random
			xx = Math.random() * can.width;
			if(rand2 == 0)
				yy = -bad.height;
			else
				yy = can.height;
		}
		else{ //the y is random
			yy = Math.random() * can.height;
			if(rand2 == 0)
				xx = -bad.width;
			else
				xx = can.width;
		}
		
		bad.x = xx;
		bad.y = yy;
		
		baddies.push(bad);
	}
	
	function addBullet(b){//b must include these vars: x, y, width (5), height (5), speed (300), angle, damage (25)
		bullets.push(b);
	}
	
	function addTree(xx,yy,t){//x and y position. the "t" is a string, indicating the type of tree
		var OBJ;
		
		switch(t){
			case "master":
				OBJ = STORAGE.master;
				break;
			case "manufactured":
				OBJ = STORAGE.manufactured;
				break;
			case "oak":
				OBJ = STORAGE.oak;
				break;
			case "petrified":
				OBJ = STORAGE.petrified;
				break;
		}
		
		trees.push({
			x: xx,
			y: yy,
			width: 50,
			height: 50,
			WAIT: OBJ.WAIT,
			timeToWait: OBJ.timeToWait,
			health: OBJ.health,
			range: OBJ.range,
			type: t,
			bulletToFire: {
				x: xx - 25,
				y: yy - 25,
				width: 5,
				height: 5,
				angle: 0,
				speed: 300,
				damage: OBJ.bulletToFire.damage
				}
			});
	}
	
	function addSpeechBubble(xx,yy,t){//xposition, y posistion, type
		//switch?
		var q = "";
		var num = Math.random();
		switch(t){
			case "master":
				q = QUOTES.master[Math.floor(QUOTES.master.length * num)];
				break;
			case "manufactured":
				q = QUOTES.manufactured[Math.floor(QUOTES.manufactured.length * num)];
				break;
			case "oak":
				q = QUOTES.oak[Math.floor(QUOTES.oak.length * num)];
				break;
			case "petrified":
				q = QUOTES.petrified[Math.floor(QUOTES.petrified.length * num)];
				break;
			default:
				q = "QUOTE ERROR";
		}
		speechBubbles.push({
			x: xx,
			y: yy,
			quote: q,
			timeLeft: 3000,
		});
	}
	
	function addPickUp(xx, yy, val){ //x position, y position, value
		pickUp.push({
			x: xx,
			y: yy,
			width: 10,
			height: 10,
			val: val,
			});
	}
		
	function collide(obj1,obj2){
		if(obj1.x + obj1.width <= obj2.x)
			return false;
		if(obj1.y + obj1.height <= obj2.y)
			return false;
		if(obj2.x + obj2.width <= obj1.x)
			return false;
		if(obj2.y + obj2.height <= obj1.y)
			return false;
		
		return true;
	}
	
	
	
	//****************************INTRO********************
	
	
	
	function introUpdate(time){
		
	}
	
	function introDraw(){
		ctx.clearRect(0,0,800,600);
		ctx.fillStyle="black";
		ctx.fillRect(0,0,800,600);
		ctx.fillStyle="white";
		ctx.font="18pt serif";
		ctx.fillText("The year is 2093.",100,100);
		ctx.fillText("The world is in ruins.",100,150);
		ctx.fillText("One can't walk but 10 feet without being killed by a Mecha-Mitchell.",100,200)
		ctx.fillText("Only one man can save the world.",100,250);
		ctx.fillText("That man is Kibody, the Tree Master.",100,300);
		
		ctx.fillStyle = "green";
		ctx.fillRect(backButton.x,backButton.y,backButton.width,backButton.height);
		
		ctx.fillStyle="black";
		var ms = {x: mouse.x, y: mouse.y, width: 0, height: 0};
		if(collide(ms,playButton)){
			ctx.font="34pt Helvetica";
			ctx.fillText("Back",345,395);
		}
		else{
			ctx.font="30pt Helvetica";
			ctx.fillText("Back",350,400);
		}
	}
	
	function introSetup(){
		update = introUpdate;
		draw = introDraw;
	}
	
	
	
	//****************************MENU***********
	
	
	
	function menuUpdate(time){
		if ( mouse.clicked && contains(playButton, mouse) === true )
			playSetup();
		if ( mouse.clicked && contains(introButton, mouse) === true )
			introSetup();
	}
	
	function menuDraw(){
		ctx.clearRect(0,0,can.width,can.height);
		ctx.fillStyle="green";
		ctx.fillRect(playButton.x, playButton.y, playButton.width, playButton.height);
		ctx.fillRect(introButton.x,introButton.y,introButton.width,introButton.height);
		
		ctx.fillStyle="black";
		var ms = {x: mouse.x, y: mouse.y, width: 0, height: 0};
		if(collide(ms,playButton)){
			ctx.font="34pt Helvetica";
			ctx.fillText("Play!",345,395);
		}
		else{
			ctx.font="30pt Helvetica";
			ctx.fillText("Play!",350,400);
		}
		
		if(collide(ms,introButton)){
			ctx.font="34pt Helvetica";
			ctx.fillText("Story!",345,495);
		}
		else{
			ctx.font="30pt Helvetica";
			ctx.fillText("Story!",350,500);
		}
		
		ctx.font="30pt Helvetica";
		ctx.fillText("Game Thingy 1.7!",250,100);
	}
	
	function menuSetup(){
		update = menuUpdate;
		draw = menuDraw;
	}
	
	
	
	//*****END GAME FUNCTIONS*****
	
	
	
	function endUpdate(time){
		endTime -= time;
		
		if(endTime <= 0)
			menuSetup();
	}
	
	function endDraw(){
		ctx.clearRect(0,0,can.width,can.height);
		ctx.font = "34pt Helvetica";
		ctx.fillStyle = "#000000";
		ctx.fillText("GAME OVER",250,300);
	}
	
	function endSetup(){
		update = endUpdate;
		draw = endDraw;
		
		endTime = endWaitTime;
	}
	
	
	
	//*****TICK FUNCTION*****
	
	
	
	function tick(time){
		var deltaTime = time - lastTickTime;
		
		draw();
		
		accumulate += deltaTime;
		
		while(accumulate >= UPDATEINTERVAL){
			update(UPDATEINTERVAL);
			accumulate -= UPDATEINTERVAL;
		}
		
		lastTickTime = time;
		window.requestAnimationFrame(tick);
	}
	
	//****Handling buttons being pressed*****
	function handleKeyDown(evt){
		if(evt.keyCode == 87)//w
			player.up = true;
		if(evt.keyCode == 83)//s
			player.down = true;
		if(evt.keyCode == 65)//a
			player.left = true;
		if(evt.keyCode == 68)//d
			player.right = true;
		if(evt.keyCode == 69)//e
			player.e = true;
		if(evt.keyCode == 81)//q?
			player.q = true;
			
		if(65 <= evt.keyCode && evt.keyCode >= 90)
			evt.preventDefault();
	}
	
	function handleKeyUp(evt){
		if(evt.keyCode == 87)//w
			player.up = false;
		if(evt.keyCode == 83)//s
			player.down = false;
		if(evt.keyCode == 65)//a
			player.left = false;
		if(evt.keyCode == 68)//d
			player.right = false;
		if(evt.keyCode == 69)//e
			player.e = false;
		if(evt.keyCode == 81)//q?
			player.q = false;
			
		if(65 <= evt.keyCode && evt.keyCode >= 90)
			evt.preventDefault();
	}
	
	function handleClick(evt){
		var ms = {
				x: mouse.x,
				y: mouse.y,
				width: 0,
				height: 0};
		if(player.timeToWait <= 0 && update == playUpdate){
			var bul = {
				x: player.x + (player.width * 0.5) - (player.bulletToFire.width * 0.5),
				y: player.y + (player.height * 0.5) - (player.bulletToFire.height * 0.5),
				width: player.bulletToFire.width,
				height: player.bulletToFire.height,
				angle:0,
				speed: player.bulletToFire.speed,
				damage: player.bulletToFire.damage,
			};
						
			bul.angle = Math.atan2(mouse.y - player.y - (player.height * 0.5), mouse.x - player.x - (player.width * 0.5));
			
			var change = Math.random()*(Math.PI/15) - (Math.PI/30);
			bul.angle += change;
			if(bul.angle > Math.PI)
				bul.angle -= 2*Math.PI;
			else if(bul.angle < -1.0*Math.PI)
				bul.angle += 2*Math.PI
			
			addBullet(bul);
			player.timeToWait = player.WAIT;
		}
		else if(update == menuUpdate){
			if(collide(ms,playButton))
				playSetup();
			else if(collide(ms,introButton))
				introSetup();
		}
		else if(update == introUpdate){
			if(collide(ms,backButton))
				menuSetup();
		}
			
		evt.preventDefault();
	}
	
	function setMousePosition(event){
		mouse.x = event.clientX - canvas.getBoundingClientRect().left;
		mouse.y = event.clientY - canvas.getBoundingClientRect().top + 0.875;
		
		event.preventDefault();
	}
	//****End handling buttons being pressed**
		
	function loadJSON(callback) {//not working?
		var xhr = new XMLHttpRequest();
		xhr.overrideMimeType("application/json");
		xhr.open('GET', 'jsonTrees.json', true);
		xhr.onreadystatechange = function () {
			if (xhr.readyState == 4 && xhr.status == "200") {
				callback(xhr.responseText);
			}
		};
		xhr.send(null);
	}

	
	function main(){
		ctx = document.getElementById('canvas').getContext("2d");
		
		//Here, I add all of the items into the "STORAGE" variable.
		STORAGE = {
			master: {
				x: 0,
				y: 0,
				width: 50,
				height: 50,
				WAIT: 2000,
				timeToWait: 2000,
				health: 300,
				range: 0,
				type: "master",
				bulletToFire: {
					x: 0,
					y: 0,
					width: 5,
					height: 5,
					angle: 0,
					speed: 300,
					damage: 25
				}
			},
			
			manufactured: {
				x: 0,
				y: 0,
				width: 50,
				height: 50,
				WAIT: 2000,
				timeToWait: 2000,
				health: 100,
				range: 200,
				type: "manufactured",
				bulletToFire: {
					x: 0,
					y: 0,
					width: 5,
					height: 5,
					angle: 0,
					speed: 300,
					damage: 25
				}
			},
			
			oak: {
				x: 0,
				y: 0,
				width: 50,
				height: 50,
				WAIT: 10000,
				timeToWait: 10000,
				health: 100,
				range: 75,
				type: "oak",
				bulletToFire: {
					x: 0,
					y: 0,
					width: 5,
					height: 5,
					angle: 0,
					speed: 300,
					damage: 80
				}
			},
			
			petrified: {
				x: 0,
				y: 0,
				width: 50,
				height: 50,
				WAIT: 2000,
				timeToWait: 2000,
				health: 500,
				range: 100,
				type: "petrified",
				bulletToFire: {
					x: 0,
					y: 0,
					width: 5,
					height: 5,
					angle: 0,
					speed: 300,
					damage: 5
				}
			}
		}
		
		QUOTES = {
			master: [ "I AM YOUR GOD", "PROTECT ME, MINIONS"],
			manufactured: ["~Virus Detected~", "~Commencing Cleanup~"],
			oak: ["Ew! A spider!", "Kill it with fire!"],
			petrified: ["That tickles...", "Are you trying to hurt me?"]
			};
		
		menuSetup();
		
		window.requestAnimationFrame(tick);
	}
	
	document.addEventListener('keydown', handleKeyDown);
	document.addEventListener('keyup', handleKeyUp);
	canvas.addEventListener('click', handleClick);
	canvas.addEventListener('drag', handleClick);
	canvas.onmousemove = function(){setMousePosition(event);};
	
	main();
	
	/*
	I will write random notes down here so you may see later on.
	
	List of trees (in order that they are on the json file)
	*master
	acts like a superior king of all beings.
	
	*manufactured
	default, basic tree. this is used as a basis of comparison for all other trees.
	
	*oak
	afraid of spiders.
	-has very close range
	-he takes a super long time to recharge after each shot. If caught off guard, this tree can die easily.
	+shoots a very powerful shot.
	
	*petrified
	brute, but also dumb.
	+has a crazy amount of health. Meant to stop enemies from moving.
	-weak attack.
	
	Notes:
	I want to look through the update function. There is some repeditive and un-needed code that can be simplified. It will also make the program run faster.
	*/
	
	</script>
</html>